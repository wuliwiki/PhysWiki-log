% g++ 编译器创建静态和动态链接库

\begin{issues}
\issueDraft
\end{issues}

\pentry{C/C++ 多文件编译\upref{cppFil}}

参考\href{https://blog.feabhas.com/2014/04/static-and-dynamic-libraries-on-linux/}{这篇文章}和\href{https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html}{这篇文章}．

\begin{itemize}
\item 用 \verb`ldd 可执行文件` 可以查看一个程序使用的所有动态链接库， 包括库所依赖的其他库
\item linux 编译器默认搜索路径（不包含子目录） \verb`/usr/local/lib`, \verb`/usr/local/lib64`, \verb`/usr/lib` and \verb`/usr/lib64`
\end{itemize}

事实上， 用 \verb|apt| 安装 \verb|lib*-dev| 就是在系统的默认搜索路径添加头文件和 \verb|lib*.a|， \verb|lib*.so| 文件， 以及它依赖的 package 中的这些文件． 这些文件在同一系统版本和同一 cpu 架构都是通用的（运气好的话也可能在不同系统中通用）．

\subsection{静态链接库}

\verb|.a| 文件是 static library, 在编译的时候一起编入可执行文件. 下面举一个例子

\begin{lstlisting}[language=cpp]
// lib1.cpp
#include <iostream>
using namespace std;
int f1()
{ cout << "In library 1" << endl; }
\end{lstlisting}

再编一个主文件

\begin{lstlisting}[language=cpp]
// main.cpp
#include <iostream>
using namespace std;
void f1();
int main()
{
  f1();
  cout << "In main" << endl;
}
\end{lstlisting}

如果将这两个文件用 g++ 正常编译 \verb`g++ main.cpp lib1.cpp` 执行结果为
\begin{lstlisting}[language=none]
In library 1
In main
\end{lstlisting}
但现在我们把 \verb|lib1.cpp| 先编译成 \verb|.o| 文件

\begin{lstlisting}[language=none]
g++ -static -c -o lib1.o lib1.cpp
\end{lstlisting}

(其实 \verb`-o lib1.o` 可以省略) （\verb`-static` 用于静态编译）, 再从 \verb|.o| 文件生成 \verb|.a| 文件 \verb|.a| 文件的命名规则一般是前面加 (\verb`lib*.a`)

\begin{lstlisting}[language=none]
ar rcs lib1.a lib1.o
\end{lstlisting}
可以将多个 \verb|.o| 文件封装到 \verb|.a| 里面, 在后面添加 \verb|lib2.o, lib3.o| 等即可． \verb`.a` 就是 \verb`.o` 的压缩文件（archive）， \verb`ar` 和 \verb`tar` 差不多． (其中 \verb|rcs| 选项中的 \verb`r` 选项是添加并替换旧文件（如果有同名）, \verb`c` 选项是 create archive, \verb`s` 选项是 write out an index, 虽然还是不明白什么意思)． 若要打印文件内容， 用 \verb|ar p lib1.a| 或者 \verb|ar pv lib1.a| （verbose）． 若要取出所有文件， 用 \verb|ar x lib1.a [文件1] [文件2]|．

再来将 \verb|lib1.a| 和主程序文件一块编译
\begin{lstlisting}[language=none]
g++ main.cpp -o main.x -L./ -l 1
\end{lstlisting}

其中 \verb`-o` 的作用是给生成的可执行文件命名, \verb`-L` 的作用是声明 \verb`.a` 所在的目录, \verb`-l` 是指明所用的 .a 文件, (将 \verb`lib*.a` 写成 \verb`*` 即可).
现在就可以运行 main.x 了
\verb`./main.x`

\begin{itemize}
\item 所以简单来说， 静态链接库 \verb`.a` 就是 archive 的 \verb`.o` 文件． 在 link 阶段使用．
\item 另外要注意 \verb`g++` 在（静态） link 阶段 \verb`.o` 或 \verb`.a` 的顺序是非常重要的， 某个 \verb`o` 文件只能调用在它后面列出的 \verb`o` 文件， 否则会提示找不到 symbol． 要让 \verb`g++` 忽略这个顺序， 可以使用
\item 关于 so 动态链接库和 ELF 的一个\href{https://amir.rachum.com/blog/2016/09/17/shared-libraries/}{详细教程}．
\item 要强制 \verb|g++| 进行动态链接， 可以用 \verb|-l| 的另一种形式 \verb|-l :libXXX.so|． 其中 \verb|:文件名| 直接搜索 \verb|文件名|， 而不是 \verb|lib文件名.so或a|．
\verb`-Wl,--start-group 文件1 文件2 ... -Wl,--end-group`， 这样 linker 找不到 symbol 时就会在 group 内的文件中反复搜索（编译速度会降低）．
\item 注意 \verb|-L| 和 \verb|rpath| 里面的路径可以是相对路径， 但如果 \verb|rpath| 用相对路径， 那么可执行文件和 so 文件就必须保持相对位置否则运行时会找不到．
\item 总之， 有空还是多看看 \verb`g++` 手册吧．
\item 注意 \verb|ldd| 未必会显示所有依赖的库（我猜有一些可能是程序运行中途加载的，例如在源码中加载而不是在 link 阶段加载）．
\addTODO{看一下 \verb|dlopen()| 函数有什么用．}
\item 另外 \verb|ldd| 不会列出依赖树， 如果想要依赖树， 用 \verb|lddtree| （\verb|apt install pax-utils|）
\item \verb|stdc++.so.6| 即使同名，也不一定是正确的版本， 见\href{https://unix.stackexchange.com/questions/458659/what-do-the-multiple-glibc-versions-mean-in-the-output-of-ldd}{这里}． 如果不同路径都有这个文件， 似乎会自动加载正确的版本．
\end{itemize}

\subsection{动态链接库 (*.so)}
创建动态库：
\begin{lstlisting}[language=none]
g++ -shared -fPIC -o lib1.so lib1.cpp
\end{lstlisting}

使用方法:
把 cpp 编译成 .o 文件时不需要声明动态链接库和所在目录, \verb`-c` 选项普通编译即可.
\begin{lstlisting}[language=none]
g++ -c main.cpp
\end{lstlisting}
把 \verb|.o| 文件链接成可执行文件时, 在最后 (注意必须是在最后) 加上
\verb`-Wl,-rpath,<library path>  -L<library path> -l <libname1> -l <libname2>`
其中 \verb`-Wl,aaa,bbb` 命令是将 \verb`aaa bbb` 选项传给 linker, 剩下的 \verb`-L<library path> -l <libname1> -l <libname2>` 的用法和上述 \verb|.a| 中的一样.
\begin{lstlisting}[language=none]
g++ -o main.x main.o -l1 -L./ -Wl,-rpath,./
\end{lstlisting}
可以用 \verb|ldd main.x| 查看动态链接库， 会发现其中有 \verb|lib1.so|． 如果不用 \verb|rpath|， 也可以在执行可执行文件以前把路径加入到环境变量 \verb`LD_LIBRARY_PATH` 中． \verb|rpath| 和 \verb|LD_LIBRARY_PATH| 可以是相对于可执行文件的相对路径， 也可以是绝对路径． 也可以用 \verb|$ORIGIN| 表示可执行文件的路径
\begin{lstlisting}[language=none]
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/your/custom/path/
\end{lstlisting}
\begin{itemize}
\item 注意 \verb|rpath| 只能设定当前可执行文件的的路径， 如果可执行文件依赖的 \verb|.so| 文件所需要的 \verb|.so| 文件不在默认路径， 就只能通过修改 \verb`LD_LIBRARY_PATH` 才可以．
\item \verb|LD_LIBRARY_PATH| 中不可以有关键的系统 \verb|.so| 文件， 否则如果不兼容很多系统命令像 \verb|ls, touch, echo| 等都会用不了．
\item 另外 \verb|g++| 中的 \verb|-L| 选项（make 的时候搜索静态或动态库的路径）可以用环境变量 \verb|LIBRARY_PATH| 设置， \verb|-I| 选项（搜索头文件的路径）可以用环境变量 \verb|CPATH| 设置．
\item \verb|LIBRARY_PATH| 的顺序很重要， 如果同名 \verb|.a| 的路径出现在同名 \verb|.so| 路径的前面， 那么就会链接 \verb|.a|． 如果二者的路径相同， 那么还是会有限链接 \verb|.so|．
\item 如果不指定 \verb|rpath|， 设置环境变量 \verb|LD_RUN_PATH| 也是等效的． 链接的程序是 \verb|ld|， 而动态链接库是 \verb|ld-linux.so|
\item 如果要修改已经编译好的可执行文件（包括 so） 的 rpath， 可以用 \verb|chrpath| 或者 \verb|patchelf --set-rpath '路径' XXX.so| 其中如果要设置相对路径如 \verb|'$ORIGIN/相对路径'| 参考\href{https://stackoverflow.com/questions/13769141/can-i-change-rpath-in-an-already-compiled-binary}{这里}． 用这种方法， 加上 rpath 中的 \verb|ORIGIN| 功能， 似乎可以像 AppImage 或者 snap 一样把任何动态链接的程序打包到同一个文件夹中， 包括所有依赖， 也就是所谓的绿色软件．
\item 如果同样的 \verb`-l` 既能匹配 \verb`lib***.a` 也能匹配 \verb`lib***.so`， 那么 gcc 会默认选 \verb`.so` （貌似有时候二者都需要）． 如果想要静态链接， 要么用 \verb`-static` 选项（禁止链接到任何动态 lib）， 要么直接指定 \verb`.a` 的地址和文件名， 如 \verb`g++ -o main.x f1.o /some/path/lib***.a another/path/lib***.a`．
\item 注意带版本号的 \verb|lib***.so.x.x| 不会自动匹配， 一般存在一个名为 \verb|lib***.so| 的软链指向某个具体的版本．
\item 如果要查看 \verb|.a| 或 \verb|.so| 文件里面是否有某个函数， 用例如 \verb`nm -A /usr/lib/x86_64-linux-gnu/libflint.a | grep fmpz_set` 类似地也有 \verb|nm xxx.so|
\item 如果 \verb|rpath| 是相对路径， 那么它相对的是 pwd 而不是可执行文件的位置， 定义时可以使用 \verb|${ORIGIN}| 来表示可执行文件的位置．
\item \verb`objdump -x 可执行文件或者so库 |grep RUNPATH或RPATH` 可以查看 \verb|可执行文件或者so库| 的 rpath．
\item \verb|readelf -s 链接库.so| 可以检查里面的 symbols． 详见\href{https://amir.rachum.com/blog/2016/09/17/shared-libraries/}{这个教程}．
\end{itemize}

Linux 程序运行时搜索动态链接库的顺序（简化版，详见\href{https://unix.stackexchange.com/questions/22926/where-do-executables-look-for-shared-objects-at-runtime}{这里}以及 \href{https://man7.org/linux/man-pages/man8/ld.so.8.html}{man8}）：
\begin{itemize}
\item 环境变量 \verb|LD_LIBRARY_PATH|
\item 可执行文件的 \verb|rpath|
\item \verb|/lib/| 和 \verb|/usr/lib/| 中的， 以及 \verb|/etc/ld.so.conf.d| 中的文件
\end{itemize}

其他笔记：
\begin{itemize}
\item \verb`ld --verbose | grep SEARCH_DIR | tr -s ' ;' \\012` 可以查看 \verb|linker| 的默认搜索路径
\item \verb|sudo ldconfig| 可以更新动态链接库的搜索
\item \verb`ldconfig -p | grep 库名` 可以查看除了 \verb|LD_LIBRARY_PATH| 之外的所有动态搜索路径中有没有某个 \verb|.so|．
\item \verb`ldconfig -N -v $(sed 's/:/ /g' <<< $LD_LIBRARY_PATH) 2>&1 | grep 库名` 可以包括 \verb|LD_LIBRARY_PATH|
\end{itemize}

\subsection{多个动态库}
动态库本身也可以依赖于其他动态库， 例如再添加一个程序
\begin{lstlisting}[language=cpp]
// lib0.cpp
#include <iostream>
using namespace std;
void f0()
{
  cout << "In library 0" << endl;
}
\end{lstlisting}
然后修改 \verb|lib1|
\begin{lstlisting}[language=cpp]
// lib1.cpp
#include <iostream>
using namespace std;
void f1()
{
  cout << "In library 1" << endl;
  void f0();
  f0();
}
\end{lstlisting}
制作库
\begin{lstlisting}[language=none]
g++ -c lib0.cpp lib1.cpp // 生成 lib0.o lib1.o
g++ -shared -fPIC -o lib0.so lib0.cpp
g++ -shared -fPIC -o lib1.so lib1.cpp -l0 -L./ -Wl,-rpath,./
\end{lstlisting}
编译主程序， 使用库， 注意只需要链接 \verb|lib1|
\begin{lstlisting}[language=none]
g++ -c main.cpp
g++ -o main.x main.o -l1 -L./ -Wl,-rpath,./
\end{lstlisting}
用 \verb|ldd main.x| 检查所有依赖的动态库， 会发现 \verb|lib0, lib1| 都在．
