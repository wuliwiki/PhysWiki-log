% 编译器/解释器简介、Bison 和 Reflex 笔记
% license Xiao
% type Note

\begin{issues}
\issueDraft
\end{issues}

\begin{itemize}
\item 参考\href{https://www.toptal.com/scala/writing-an-interpreter}{这篇文章}，还有\href{https://www.youtube.com/watch?v=Xu4RtLlm42I}{这个}
\item lexer
\item parser
\item interpreter
\item abstract syntax tree (AST)
\item domain-specific languages (DSLs)
\item 一个纯手写 c 编译器\href{https://norasandler.com/2017/11/29/Write-a-Compiler.html}{教程}。
\item \href{https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html}{llvm 前端教程}：用 c++ 写自己的第一个语言（会 c++ 就行，不需要其他基础）
\item baltam 用的是 \href{https://www.gnu.org/software/bison/}{bison} 和 \href{https://www.genivia.com/doc/reflex/html/}{RE/flex}
\item 用 bison 实现一个简单科学计算器（包括变量赋值和基本函数） 的例子 \href{http://web.mit.edu/gnu/doc/html/bison_5.html}{Multi-Function Calculator: mfcalc}。
\item 笔者自己的简陋 Matlab 实现： 见\href{https://github.com/MacroUniverse/bison_test}{这里}。
\item \href{https://en.wikipedia.org/wiki/LR_parser}{LR parser}， \href{https://en.wikipedia.org/wiki/LALR_parser}{LALR parser}， \href{https://en.wikipedia.org/wiki/Recursive_descent_parser}{Recursive Descent parser} （G++ 和 Clang 都用是手写的 Recursive Descent）， \href{https://en.wikipedia.org/wiki/GLR_parser}{GLR parser} （例子： \href{http://www.scottmcpeak.com/elkhound/}{Elsa C++ parser} 和 \href{http://www.semanticdesigns.com/Products/FrontEnds/CppFrontEnd.html}{C++ Parser Front End}）
\item 上一条参考 C/C++ parser 的一个 \href{https://stackoverflow.com/questions/6319086/are-gcc-and-clang-parsers-really-handwritten}{Stack Overflow 问题}。
\item 然而 TeX 的编译器要复杂得多（如果要实现全部功能）见\href{https://groups.google.com/g/comp.text.tex/c/E1736iEOxNI}{这个讨论}。 现成的工具参考\href{https://tex.stackexchange.com/questions/39309/convert-latex-to-html}{这个}。
\end{itemize}

\subsection{Bison 笔记}
\begin{itemize}
\item 安装： \verb`apt install bison`
\item 使用： \verb`bison xxx.y` (\verb`-d` 选项用于生成头文件)
\item 编译 \verb`gcc xxx.tab.c -l xxx -o xxx`
\item \href{http://web.mit.edu/gnu/doc/html/bison_5.html}{官方例子}源文件见笔者的 \href{https://github.com/MacroUniverse/bison_test}{GitHub}。
\item 调试的时候，若要在任何规则适配时用断点暂停， 可以首先用 \verb`--no-line` 选项取消行号，然后在生成的 cpp 文件中 \verb`switch (yyn)` 这句上中打断点。
\end{itemize}

\subsubsection{mfcalc 笔记}
\begin{itemize}
\item symbol 就是 VAR, FUNC
\end{itemize}

\subsection{Reflex 笔记}
\verb`.l` 文件基础
\begin{itemize}
\item \verb`.l` 文件的注释用 \verb`//` 或 \verb`/**/` 和 C 一样
\item \verb`%top{ ... }` 会把一段代码放在 .hpp 和 .cpp 文件的开头
\item \verb`%class{ ... }` 定义 lexer class (custom lexer implementation)，如 \verb`class MyLexer : public reflex::AbstractLexer { ... };`
\item \verb`%init{ ... }` 定义 lexer 初始化的代码，如 \verb`printf("Lexer initialized!\n");`
\item \verb`%s` 和 \verb`%x` 定义 lexer states， 分别是 inclusive 和 exclusive。如 \verb`%s STATE_COMMENT STATE_CLASS`，不同 state 可能有不同规则。
\end{itemize}
