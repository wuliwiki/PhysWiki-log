% 冯·诺伊曼-博内斯-哥德尔集合论（综述）
% license CCBYSA3
% type Wiki

本文根据 CC-BY-SA 协议转载翻译自维基百科\href{https://en.wikipedia.org/wiki/Von_Neumann\%E2\%80\%93Bernays\%E2\%80\%93G\%C3\%B6del_set_theory}{相关文章}。

在数学基础中，冯·诺依曼–伯奈斯–哥德尔集合论（NBG）是一种公理化集合论，是泽梅洛–弗兰克尔–选择公理集合论（ZFC）的保守扩展。NBG 引入了“类”的概念，类是由公式定义的集合，其量词仅对集合进行量化。NBG 可以定义比集合更大的类，例如所有集合的类和所有序数的类。摩尔斯–凯利集合论（MK）允许通过量词对类进行量化的公式来定义类。NBG 是有限公理化的，而 ZFC 和 MK 则不是。

NBG 的一个关键定理是类存在定理，它声明，对于每个量词仅对集合进行量化的公式，都存在一个类，该类包含满足该公式的集合。这个类是通过用类逐步构造公式来构建的。由于所有集合论公式都是由两种原子公式（成员关系和相等性）和有限多的逻辑符号构成，因此只需要有限多的公理来构建满足这些公式的类。这就是为什么 NBG 是有限公理化的原因。类还用于其他构造、处理集合论悖论，并用于表述全局选择公理，该公理比 ZFC 的选择公理要强。

约翰·冯·诺依曼在 1925 年将类引入集合论。他的理论的原始概念是函数和参数。利用这些概念，他定义了类和集合。\(^\text{[1]}\)保罗·伯奈斯通过将类和集合作为原始概念重新表述了冯·诺依曼的理论。\(^\text{[2]}\)库尔特·哥德尔简化了伯奈斯的理论，用于他对选择公理和广义连续统假设相对一致性的证明。\(^\text{[3]}\)
\subsection{集合论中的类} 
\subsubsection{类的用途} 
在 NBG 中，类有几个用途：
\begin{itemize}
\item 它们产生了集合论的有限公理化。\(^\text{[4]}\)  
\item 它们用于表述“非常强的选择公理”\(^\text{[5]}\)——即全局选择公理：存在一个定义在所有非空集合类上的全局选择函数\( G \)，使得对于每个非空集合\( x \)，都有 \( G(x) \in x \)。  
   这比 ZFC 的选择公理要强：对于每个非空集合的集合\( s \)，存在一个选择函数 \( f \)，定义在\( s \)上，使得对于所有\( x \in s \)，都有\( f(x) \in x \)。  
\item 通过认识到某些类不能是集合，集合论悖论得以解决。例如，假设所有序数的类 \( \text{Ord} \)是一个集合。那么\( \text{Ord} \)是一个按\( \in \)良序的传递集合。所以，根据定义，\( \text{Ord} \)是一个序数。因此，\( \text{Ord} \in \text{Ord} \)，这与\( \in \)是\( \text{Ord} \)的良序性相矛盾。因此，\( \text{Ord} \)不是一个集合。不能是集合的类称为适当类；\( \text{Ord} \)是一个适当类。\(^\text{[6]}\)
\item 适当类在构造中很有用。在他证明全局选择公理和广义连续统假设的相对一致性时，哥德尔使用适当类来构建构造宇宙。他在所有序数的类上构造了一个函数，对于每个序数，通过对先前构造的集合应用集合构建操作来构造一个构造集。构造宇宙就是这个函数的像。\(^\text{[7]}\)
\end{itemize}
\subsubsection{公理模式与类存在定理}  
一旦类被添加到 ZFC 的语言中，就可以轻松地将 ZFC 转换为一个包含类的集合论。首先，添加类理解的公理模式。这个公理模式声明：对于每个仅对集合进行量化的公式\( \phi(x_1, \ldots, x_n) \)，存在一个类\( A \)，由满足该公式的\( n \)-元组组成——即：
\[
\forall x_1 \cdots \forall x_n \left[ (x_1, \ldots, x_n) \in A \iff \phi(x_1, \ldots, x_n) \right].~
\]
然后，替换公理模式被替换为一个使用类的单一公理。最后，ZFC 的外延公理被修改以处理类：如果两个类有相同的元素，则它们是相同的。ZFC 的其他公理没有被修改。\(^\text{[8]}\)

这个理论不是有限公理化的。ZFC 的替换公理模式已被一个单一公理所替代，但类理解的公理模式被引入。

为了产生一个有限公理化的理论，首先将类理解的公理模式替换为有限多个类存在公理。然后，这些公理被用来证明类存在定理，该定理暗示公理模式的每个实例。\(^\text{[8]}\)这个定理的证明只需要七个类存在公理，这些公理用于将公式的构造转换为满足该公式的类的构造。
\subsection{NBG 的公理化}  
\subsubsection{类和集合}  
NBG 有两种类型的对象：类和集合。直观上，每个集合也是一个类。公理化这一点有两种方式。[需要非主要来源] 伯奈斯使用了多种排序逻辑，包含两种排序：类和集合。\(^\text{[2]}\)哥德尔通过引入原始谓词避免了排序问题：\( \mathfrak{Cls}(A) \)表示 “A 是一个类”，  
\( \mathfrak{M}(A) \)表示 “A 是一个集合”（在德语中，“集合”是“ Menge”）。他还引入了公理，声明每个集合都是一个类，并且如果类\( A \)是某个类的成员，则\( A \)是一个集合。\(^\text{[9]}\)使用谓词是消除排序的标准方式。埃利奥特·门德尔森修改了哥德尔的方法，使得一切都是类，并将集合谓词\( M(A) \)定义为\( \exists C (A \in C) \)。\(^\text{[10]}\)这种修改消除了哥德尔的类谓词和他的两个公理。

伯奈斯的两排序方法可能一开始看起来更自然，但它创造了一个更复杂的理论。\(^\text{[b]}\)在伯奈斯的理论中，每个集合有两种表示方式：一种作为集合，另一种作为类。此外，有两个成员关系：第一个，表示为“∈”，用于两个集合之间；第二个，表示为“η”，用于集合与类之间。\(^\text{[2]}\) 这种冗余是多种排序逻辑所需要的，因为不同排序的变量作用于论域的不同子域。

这两种方法之间的差异不会影响可证明的内容，但会影响如何编写命题。在哥德尔的方法中，\( A \in C \)（其中\( A \)和\( C \)是类）是一个有效的命题。在伯奈斯的方法中，这个命题没有意义。然而，如果\( A \)是一个集合，就有一个等效的命题：定义“集合\( a \)表示类\( A \)”如果它们有相同的成员集合——即，\(\forall x (x \in a \iff x \eta A)\)命题\( a \eta C \)（其中集合\( a \)表示类\( A \)）等价于哥德尔的\( A \in C \)。\(^\text{[2]}\)

本文采用的方法是哥德尔加上门德尔森的修改。这意味着 NBG 是一个基于一阶谓词逻辑的公理化系统，具有相等性，其唯一的原始概念是类和成员关系。
\subsubsection{外延性公理和配对公理的定义和公理} 
集合是至少属于一个类的类：\( A \) 是一个集合当且仅当\( \exists C (A \in C) \)。不是集合的类称为适当类：\( A \)是一个适当类当且仅当\( \forall C (A \notin C) \)。\(^\text{[12]}\)因此，每个类要么是一个集合，要么是一个适当类，且没有类既是集合又是适当类。

哥德尔引入了一个约定，即大写字母变量作用于类，而小写字母变量作用于集合。\(^\text{[9]}\)哥德尔还使用以大写字母开头的名称来表示特定的类，包括定义在所有集合类上的函数和关系。本文采用了哥德尔的约定。这使得我们可以写作：
\[
\exists x \, \phi(x)~
\]
代替  
\[
\exists x \left( \exists C (x \in C) \land \phi(x) \right)~
\]
\[
\forall x \, \phi(x)~
\]
代替  
\[
\forall x \left( \exists C (x \in C) \implies \phi(x) \right)~
\]
以下公理和定义是证明类存在定理所需的。

\textbf{外延性公理} 
如果两个类有相同的元素，则它们是相同的。

\[
\forall A \, \forall B \, \left[ \forall x \, (x \in A \iff x \in B) \implies A = B \right]^\text{[13]}~
\] 
该公理将 ZFC 的外延性公理推广到类。

\textbf{配对公理} 
如果\( x \)和\( y \)是集合，那么存在一个集合\( p \)，它的唯一成员是\( x \)和\( y \)。

\[
\forall x \, \forall y \, \exists p \, \forall z \, \left[ z \in p \iff (z = x \lor z = y) \right]^\text{[14]}~
\]
与 ZFC 中一样，外延性公理暗示了集合\( p \)的唯一性，这使我们能够引入符号\( \{x, y\} \)。

\textbf{有序对通过以下方式定义：}
\[
(x, y) = \{\{x\}, \{x, y\}\}~
\]
元组通过有序对递归定义：
\[
(x_1) = x_1,~
\]
对于 \( n > 1 \)：
\[
(x_1, \ldots, x_{n-1}, x_n) = ((x_1, \ldots, x_{n-1}), x_n).^\text{[c]}~
\]  
\subsubsection{类存在公理和正则性公理}  
类存在公理将用于证明类存在定理：对于每个仅对集合进行量化的包含\( n \)个自由集合变量的公式，都存在一个满足该公式的\( n \)-元组类。以下示例从两个类（函数）开始，并构建一个复合函数。这个例子展示了证明类存在定理所需的技术，这些技术最终引出了需要的类存在公理。

\textbf{示例 1}：如果类\( F \)和\( G \)是函数，那么复合函数\( G \circ F \)由以下公式定义：
\[
\exists t \left[ (x,t) \in F \land (t,y) \in G \right].~
\]
由于该公式有两个自由集合变量\( x \)和\( y \)，类存在定理构造了有序对的类：
\[
G \circ F = \{ (x,y) : \exists t \left[ (x,t) \in F \land (t,y) \in G \right] \}.~
\]
由于该公式是通过使用合取\( \land \)和存在量化\( \exists \)从更简单的公式构造的，因此需要类操作，这些操作将表示简单公式的类结合起来，并生成表示含有\( \land \)和\( \exists \)的公式的类。为了生成表示含有\( \land \)的公式的类，可以使用交集，因为\( x \in A \cap B \iff x \in A \land x \in B \)。

为了生成表示含有\( \exists \)的公式的类，可以使用域，因为\( x \in \text{Dom}(A) \iff \exists t \left[ (x,t) \in A \right] \)。

在进行交集之前，必须给\( F \)和\( G \)中的元组添加一个额外的组件，以使它们有相同的变量。将变量\( y \)添加到\( F \)的元组中，将变量\( x \)添加到\( G \)的元组中：
\[
F' = \{ (x,t,y) : (x,t) \in F \} \quad \text{和} \quad G' = \{ (t,y,x) : (t,y) \in G \}.~
\]
在\( F' \)的定义中，变量\( y \)不受\( (x,t) \in F \)语句的限制，因此\( y \)在所有集合的类\( V \)中取值。类似地，在\( G' \)的定义中，变量\( x \)在\( V \)中取值。因此，需要一个公理来将一个额外的组件（其值范围在\( V \)中）添加到给定类的元组中。

接下来，变量按照相同的顺序排列，以准备进行交集操作：
\[
F'' = \{ (x, y, t) : (x, t) \in F \}~
\]
和
\[
G'' = \{ (x, y, t) : (t, y) \in G \}.~
\]
从\( F' \)到\( F'' \)和从\( G' \)到\( G'' \)需要两次不同的排列，因此需要支持元组组件排列的公理。

\( F'' \) 和 \( G'' \) 的交集处理了合取 \( \land \)：
\[
F'' \cap G'' = \{ (x, y, t) : (x, t) \in F \land (t, y) \in G \}.~
\]
由于\( (x, y, t) \)被定义为\( ((x, y), t) \)，对\( F'' \cap G'' \)取域处理了\( \exists t \)并生成了复合函数：
\[
G \circ F = \text{Dom}(F'' \cap G'') = \{ (x, y) : \exists t ((x, t) \in F \land (t, y) \in G) \}.~
\]
因此，需要交集和域的公理。

类存在公理分为两组：一组处理语言原语，另一组处理元组。第一组有四个公理，第二组有三个公理。\(^\text{[d]}\)

\textbf{处理语言原语的公理：}

\textbf{成员关系} 
存在一个类\( E \)，其中包含所有有序对，其第一个组件是第二个组件的成员。
\[
\exists E \, \forall x \, \forall y \, \left[ (x, y) \in E \iff x \in y \right]^\text{[18]}~
\]

\textbf{交集（合取）} 
对于任意两个类\( A \)和\( B \)，存在一个类\( C \)，它恰好包含属于\( A \)和\( B \)的所有集合。
\[
\forall A \, \forall B \, \exists C \, \forall x \, \left[ x \in C \iff (x \in A \land x \in B) \right]^\text{[19]}~
\]
\textbf{补集（否定）}  
对于任何类\( A \)，存在一个类\( B \)，它恰好包含不属于\( A \)的所有集合。
\[
\forall A \, \exists B \, \forall x \, \left[ x \in B \iff \neg (x \in A) \right]^\text{[20]}~
\]
\textbf{域（存在量化）} 
对于任何类\( A \)，存在一个类\( B \)，它恰好包含\( A \)的有序对的第一个组件。
\[
\forall A \, \exists B \, \forall x \, \left[ x \in B \iff \exists y \, ((x, y) \in A) \right]^\text{[21]}~
\]
根据外延性公理，交集公理中的类 \( C \) 和补集与域公理中的类 \( B \) 是唯一的。它们分别表示为：\( A \cap B \)，\( \complement A \)，和 \( \text{Dom}(A) \)\(^\text{[e]}\)。

前三个公理暗示了空类和所有集合的类的存在：成员关系公理暗示存在一个类 \( E \)。  交集和补集公理暗示了存在\( E \cap \complement E \)，即空集。根据外延性公理，这个类是唯一的，它表示为\( \emptyset \)。\( \emptyset \)的补集是所有集合的类\( V \)，根据外延性公理，\( V \) 也是唯一的。集合谓词\( M(A) \)，最初定义为\( \exists C (A \in C) \)，现在重新定义为\( A \in V \)，以避免对类进行量化。

\textbf{处理元组的公理：}

\textbf{由\( V \) 生成的乘积} 
对于任何类\( A \)，存在一个类\( B \)，其元素是有序对，其中第一个组件属于\( A \)。
\[
\forall A \, \exists B \, \forall u \, [u \in B \iff \exists x \, \exists y \, (u = (x, y) \land x \in A)]^\text{[23]}~
\]
\textbf{圆形排列} 
对于任何类\( A \)，存在一个类\( B \)，其 3 元组是通过对\( A \)的 3 元组应用圆形排列\( (y, z, x) \mapsto (x, y, z) \)获得的。
\[
\forall A \, \exists B \, \forall x \, \forall y \, \forall z \, [(x, y, z) \in B \iff (y, z, x) \in A]^\text{[24]}~
\]
\textbf{交换}  
对于任何类\( A \)，存在一个类\( B \)，其 3 元组是通过交换\( A \)的 3 元组中的最后两个组件得到的。
\[
\forall A \, \exists B \, \forall x \, \forall y \, \forall z \, [(x, y, z) \in B \iff (x, z, y) \in A]^\text{[25]}~
\]
根据外延性公理，由\( V \)生成的乘积公理暗示了唯一类的存在，记作\( A \times V \)。  
这个公理用于定义所有\( n \)-元组的类\( V^n \)：\( V^1 = V \)和\( V^{n+1} = V^n \times V \)。如果 \( A \) 是一个类，外延性公理暗示 \( A \cap V^n \) 是包含\( A \)的所有\( n \)-元组的唯一类。例如，成员关系公理产生一个类 \( E \)，它可能包含非有序对的元素，而交集\( E \cap V^2 \)只包含\( E \)的有序对。

\textbf{圆形排列和交换公理}并不暗示唯一类的存在，因为它们仅指定类\( B \)的 3 元组。通过指定这些 3 元组，这些公理还指定了\( n \)-元组，适用于\( n \geq 4 \)，因为：
\[
(x_1, \ldots, x_{n-2}, x_{n-1}, x_n) = ((x_1, \ldots, x_{n-2}), x_{n-1}, x_n)~
\]
处理元组的公理和域公理暗示了以下引理，这在类存在定理的证明中得到了应用。

\textbf{元组引理}
\begin{enumerate}
\item \(\forall A \, \exists B_1 \, \forall x \, \forall y \, \forall z \, [(z, x, y) \in B_1 \iff (x, y) \in A]\)
\item \(\forall A \, \exists B_2 \, \forall x \, \forall y \, \forall z \, [(x, z, y) \in B_2 \iff (x, y) \in A]\)
\item \(\forall A \, \exists B_3 \, \forall x \, \forall y \, \forall z \, [(x, y, z) \in B_3 \iff (x, y) \in A]\)
\item \(\forall A \, \exists B_4 \, \forall x \, \forall y \, \forall z \, [(y, x) \in B_4 \iff (x, y) \in A]\)
\end{enumerate}

\textbf{证明}
\begin{itemize}
\item 类\( B_3 \): 对\( A \)应用由\( V \)生成的乘积，得到类\( B_3 \)。
\item 类\( B_2 \): 对\( B_3 \)应用交换，得到类\( B_2 \)。
\item 类\( B_1 \): 对\( B_3 \)应用圆形排列，得到类\( B_1 \)。
\item 类\( B_4 \): 对\( B_2 \)应用圆形排列，然后应用域操作，得到类\( B_4 \)。
\end{itemize}
还需要一个公理来证明类存在定理：正则性公理：由于空类的存在已经被证明，通常给出的该公理的表述如下：\(^\text{[f]}\)

\textbf{正则性公理：}每个非空集合至少有一个与其没有共同元素的元素。  
\[
\forall a \, [a \neq \emptyset \implies \exists u (u \in a \land u \cap a = \emptyset)]~
\]
这个公理意味着集合不能属于它自身：假设\( x \in x \)，且令\( a = \{x\} \)。那么\( x \cap a \neq \emptyset \)，因为\( x \in x \cap a \)。这与正则性公理矛盾，因为\( x \) 是 \( a \) 中唯一的元素。因此，\( x \notin x \)。正则性公理还禁止集合的无限递降成员序列：  
\[
\cdots \in x_{n+1} \in x_{n} \in \cdots \in x_1 \in x_0~
\]
哥德尔在他的 1940 年专著中陈述了类的正则性，而不是集合的正则性，该专著基于 1938 年的讲座。\(^\text{[26]}\)在 1939 年，他证明了集合的正则性意味着类的正则性。\(^\text{[27]}\)
\subsubsection{类存在定理}
\textbf{类存在定理}——设\( \phi(x_1, \dots, x_n, Y_1, \dots, Y_m) \)是一个仅对集合进行量化并且没有其他自由变量的公式（除了\( x_1, \dots, x_n, Y_1, \dots, Y_m \) 外，可能并不包括这些所有变量）。那么对于所有的\( Y_1, \dots, Y_m \)，存在一个唯一的类\( A \)由\( n \)-元组组成，使得：
\[
\forall x_1 \cdots \, \forall x_n \, [(x_1, \dots, x_n) \in A \iff \phi(x_1, \dots, x_n, Y_1, \dots, Y_m)]~
\]
类\( A \)被表示为：
\[
\{(x_1, \dots, x_n) : \phi(x_1, \dots, x_n, Y_1, \dots, Y_m)\}^\text{[g]}~
\]  
定理的证明将分两步进行：
\begin{enumerate}
\item 转换规则用于将给定的公式\( \phi \)转换为等价的公式，从而简化证明的归纳部分。例如，转换后的公式中只有逻辑符号\( \neg \)、\( \land \)和\( \exists \)，因此归纳仅处理这三种情况的逻辑符号。
\item 类存在定理通过归纳法证明对转换后的公式。根据转换后的公式的结构，使用类存在公理来生成满足该公式的唯一类\( n \)-元组。
\end{enumerate}
\textbf{转换规则：}在以下的规则 1 和规则 2 中，\( \Delta \)和\( \Gamma \) 表示集合或类变量。这两个规则消除了所有在\( \in \)前和所有等式中的类变量的出现。每次应用规则 1 或规则 2 到子公式时，选择\( i \)使得\( z_i \)与当前公式中的其他变量不同。三个规则会重复应用，直到没有子公式可以再应用它们为止。这样会得到一个仅由\( \neg \)、\( \land \)、\( \exists \)、\( \in \)、集合变量和类变量\( Y_k \)组成的公式，其中\( Y_k \)在\( \in \)前不会出现。

\begin{enumerate}
\item \(\displaystyle Y_{k}\in \Gamma\)被转换为\[\exists z_{i} (z_{i} = Y_{k} \land z_{i} \in \Gamma)\). 
**外延性**被用来将  
\[
\Delta = \Gamma
\]  
转换为  
\[
\forall z_{i} (z_{i} \in \Delta \iff z_{i} \in \Gamma).
\]  
**逻辑恒等式**被用来将包含 \( \lor \)、\( \implies \)、\( \iff \) 和 \( \forall \) 的子公式转换为仅使用 \( \neg \)、\( \land \) 和 \( \exists \) 的子公式。
\end{enumerate}