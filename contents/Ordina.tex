% 序数算术（综述）
% license CCBYSA3
% type Wiki

本文根据 CC-BY-SA 协议转载翻译自维基百科\href{https://en.wikipedia.org/wiki/Ordinal_arithmetic}{相关文章}。

在数学中的集合论领域，序数算术描述了序数上的三种常见运算：加法、乘法和指数运算。每种运算基本上都可以通过两种不同的方式定义：一种是构造一个明确的良序集来表示运算结果；另一种是使用跨无限递归（transfinite recursion）来定义。康托范式（Cantor normal form）提供了一种标准化的序数表示方式。除了这些常见的序数运算之外，还有“自然”序数算术以及nimber运算。
\subsection{加法}  
两个良序集 \(S\) 和 \(T\) 的和是一个序数，它表示在直积集 \(S \times \{0\}\) 和 \(T \times \{1\}\) 的并集上定义的变体字典序（即最不重要的位置优先的字典序）。这种排序方式保证了以下几点：\(S\) 中的每个元素都小于 \(T\) 中的每个元素；\(S\) 内部的比较保持原来的顺序；\(T\) 内部的比较也保持原来的顺序。 

对于序数加法 \(\alpha + \beta\)，也可以通过对\(\beta\)进行跨无限递归来定义：当右加数 \(\beta = 0\) 时，\(\alpha + 0 = \alpha\) 对任意 \(\alpha\)成立。当 \(\beta > 0\) 时，\(\alpha + \beta\)是所有\(\alpha + \delta\)（其中 \(\delta < \beta\)）中最小的严格大于它们的序数。  

具体分成后继序数和极限序数的情况：
\begin{itemize}
\item \(\alpha + 0 = \alpha\)~
\item \(\alpha + S(\beta) = S(\alpha + \beta)\) 其中 \(S\) 表示后继函数。
\item \(\alpha + \beta = \bigcup_{\delta < \beta} (\alpha + \delta)\) 当 \(\beta\)是一个极限序数时。
\end{itemize}
在自然数上，序数加法与通常的加法是相同的。  
第一个超限序数是 \(\omega\)，它是所有自然数的集合，接下来的序数是 \(\omega + 1\)、\(\omega + 2\) 等。  

\(\omega + \omega\) 表示两个按通常顺序排列的自然数副本，第二个副本完全排在第一个副本的右侧。  
用 \(0' < 1' < 2' < \dots\) 表示第二个副本，那么 \(\omega + \omega\) 看起来像：
\[
0 < 1 < 2 < 3 < \dots < 0' < 1' < 2' < \dots~
\]
这和 \(\omega\) 不同，因为在 \(\omega\) 中，只有 0 没有直接前驱，而在 \(\omega + \omega\) 中，0 和 0' 都没有直接前驱。
\subsubsection{性质}  
序数加法一般不是交换的。例如：\(3 + \omega = \omega\)因为 \(3 + \omega\) 的顺序关系是：\(0 < 1 < 2 < 0' < 1' < 2' < \dots\)
如果重新标记，就与 \(\omega\) 相同。而\(\omega + 3\)就不等于 \(\omega\)，因为它的顺序关系是：\(0 < 1 < 2 < \dots < 0' < 1' < 2'\)其中 \(2'\) 是最大元素，而 \(\omega\) 没有最大元素。（\(\omega\) 和 \(\omega + 3\) 等势，但不是序同构的。）

序数加法是结合的。例如：\((\omega + 4) + \omega = \omega + (4 + \omega) = \omega + \omega\)

加法在右参数上是严格单调且连续的：
\[
\alpha < \beta \implies \gamma + \alpha < \gamma + \beta~
\]
但对于左参数不成立。对左参数，我们只有：
\[
\alpha < \beta \implies \alpha + \gamma \leq \beta + \gamma~
\]

序数加法具有左可消性：如果\(\alpha + \beta = \alpha + \gamma\) 
那么 \(\beta = \gamma\)。此外，对于满足 \(\beta \leq \alpha\) 的序数，可以定义左减法：存在唯一的 \(\gamma\) 使得 \(\alpha = \beta + \gamma\)。  

另一方面，右消去律则不成立：
但是，加法不满足右消去律：
\[3 + \omega = 0 + \omega = \omega \text{但}3 \neq 0~\]
即使在 \(\beta \leq \alpha\) 的情况下，右减法也不成立。例如，不存在任何 \(\gamma\) 满足：\(\gamma + 42 = \omega\)

如果小于 \(\alpha\) 的所有序数在加法下封闭且包含0，那么这种 \(\alpha\)有时被称为\(\gamma\)数（见：不可加分解序数）。这样的序数恰好是形如：\(\omega^\beta\)的序数。
\subsection{乘法}
\begin{figure}[ht]
\centering
\includegraphics[width=14.25cm]{./figures/ab2f43e19990cb97.png}
\caption{不相交并集：\(\{(n,0) : n \in \mathbb{N}\} \ \cup \ \{(n,1) : n \in \mathbb{N}\}\)在最不重要位置优先的字典序下，其序型为 \(\omega \cdot 2\)。这个序型不同于\(\omega\)。} \label{fig_Ordina_1}
\end{figure}
\begin{figure}[ht]
\centering
\includegraphics[width=14.25cm]{./figures/0f5d1a0373597675.png}
\caption{集合\(\{(0,n), (1,n) : n \in \mathbb{N}\}\)在最不重要位置优先的字典序下，其序型为 \(2 \cdot \omega\)，它等于\(\omega\)。} \label{fig_Ordina_2}
\end{figure}
两个良序集 \(S\) 和 \(T\) 的笛卡尔积 \(S \times T\)，可以通过一种变体字典序（即最不重要的位置优先的字典序）来良序化。  

实际上，这相当于把 \(T\) 中的每个元素替换为一个不相交的 \(S\) 副本。  

这个笛卡尔积的序型就是 \(S\) 和 \(T\) 的序型相乘所得到的序数。

乘法的定义也可以通过对 \(\beta\) 进行跨无限递归来给出。当右侧因子 \(\beta = 0\) 时，普通乘法规则是：\(\alpha \cdot 0 = 0\)对任意序数 \(\alpha\) 都成立。当 \(\beta > 0\) 时，\(\alpha \cdot \beta\) 是所有\((\alpha \cdot \delta) + \alpha\)（其中 \(\delta < \beta\)）中最小的大于或等于它们的序数。按后继序数和极限序数两种情况分别写为：
\begin{itemize}
\item \(\alpha \cdot 0 = 0\)
\item \(\alpha \cdot S(\beta) = (\alpha \cdot \beta) + \alpha\)，其中 \(S(\beta)\) 表示 \(\beta\) 的后继序数。
\item \(\alpha \cdot \beta = \bigcup_{\delta < \beta} (\alpha \cdot \delta)\)，当 \(\beta\) 是极限序数时。
\end{itemize}

例如，\(\omega \cdot 2\)的顺序关系是：
\[
0_0 < 1_0 < 2_0 < 3_0 < \dots < 0_1 < 1_1 < 2_1 < 3_1 < \dots~
\]
这个顺序型和 \(\omega + \omega\)相同。对比 \(2 \cdot \omega\)，其顺序关系是：
\[
0_0 < 1_0 < 0_1 < 1_1 < 0_2 < 1_2 < 0_3 < 1_3 < \dots~
\]
如果重新标号，这与 \(\omega\)的顺序型相同。因此：\(\omega \cdot 2 =\omega + \omega \neq \omega = 2 \cdot \omega\)这表明序数乘法通常不是可交换的。  

与加法类似，对自然数的序数乘法与标准乘法一致。
\subsubsection{性质}  
\(\alpha \cdot 0 = 0 \cdot \alpha = 0\)，即零乘性质成立：\(\alpha \cdot \beta = 0 \implies \alpha = 0 \text{或} \beta = 0\)序数 \(1\) 是乘法单位元：\(\alpha \cdot 1 = 1 \cdot \alpha = \alpha\)
乘法是结合的：\((\alpha \cdot \beta) \cdot \gamma = \alpha \cdot (\beta \cdot \gamma)\)乘法在右参数上是严格递增且连续的：\((\alpha < \beta \text{ 且 } \gamma > 0 )\to \gamma \cdot \alpha < \gamma \cdot \beta\)乘法在左参数上不是严格递增的，例如：\(1 < 2\)但：\(1 \cdot \omega = 2 \cdot \omega = \omega\)然而，乘法在左参数上是（非严格）递增的：\(\alpha \leq \beta \to \alpha \cdot \gamma \leq \beta \cdot \gamma\)

序数的乘法一般不是可交换的。  具体来说，任何大于1的自然数都不会与任何无限序数交换。两个无限序数\(\alpha\)和\(\beta\)可交换的充要条件是：存在非零自然数\(m\)和\(n\)，使得：\(\alpha^m = \beta^n\)“\(\alpha\)与\(\beta\)可交换”这个关系是大于1的序数上的一个等价关系，并且每个等价类都是可数无穷的。

乘法对左分配律成立：\(\alpha \cdot (\beta+\gamma)=\alpha\cdot \beta+\alpha \cdot \gamma\)但右分配律一般不成立：\((\beta + \gamma) \cdot \alpha = \beta \cdot \alpha+\gamma \cdot \alpha\)并不总是对的。例如：\((1+1)\cdot \omega=2\cdot\omega = \omega\)而：\(1\cdot\omega+1\cdot \omega=\omega+\omega\)二者不同。左消去律成立：如果 \(\alpha > 0\) 且\(\alpha \cdot \beta = \alpha \cdot \gamma\)那么：\(\beta =\gamma\)右消去律不成立：例如：\(1\cdot \omega = 2\cdot\omega = \omega\)但 \(1 \neq 2\)。左除法带余数性质成立：对于任意序数\(\alpha\)和\(\beta\)，如果\(\beta > 0\)，则存在唯一的\(\gamma\)和\(\delta\)，使得：\(\alpha=\beta \cdot\gamma +\delta\)并且：\(\delta < \beta\)右除法不成立：例如，不存在\(\alpha\)使得：\(\alpha\cdot\omega \leq \omega^\omega\leq (\alpha + 1)\cdot\omega\)

序数形成一个左近似半环（left near-semiring），但不是环。因此，序数不是欧几里得整域，因为它们甚至不是环；此外，如果要定义欧几里得“范数”，根据这里的左除法，它将是一个序数值的范数。δ-数（参见乘法不可分序数）是指所有大于1的序数\(\beta\)，满足：\(\alpha \cdot \beta = \beta\)其中：\(0 < \alpha < \beta\)这样的序数包括：序数\(2\)以及所有形如\(\beta = \omega^{\omega^\gamma}\) 的序数。
\subsection{幂运算}
通过序型来定义序数的幂运算，最容易的方式是使用冯·诺伊曼序数定义：即把一个序数定义为所有比它小的序数组成的集合。

要构造序型为\(\alpha^\beta\)的集合，可以考虑所有满足以下条件的函数集合：\(f :\beta\to\alpha\)并且，这些函数只有有限个点\(x\in\beta\)满足\(f(x)=0\)（即函数具有有限支撑）。这个函数集按照最不重要位置优先的字典序排序：我们定义：\(f<g\)当且仅当存在 \(x \in \beta\) 使得：\(f(x)<g(x)\)且对于所有满足\(x < y\)的\(y\in\beta\)，都有：\(f(y) = g(y)\)这个排序是一个良序关系，因此定义了一个序数。

幂运算的定义也可以通过对指数\(\beta\)进行跨无限递归来给出。当指数\(\beta = 0\)时，普通幂运算给出：\(\alpha^0 = 1\)对任意 \(\alpha\) 都成立。当 \(\beta > 0\) 时，\(\alpha^\beta\) 是所有\(\alpha^\delta \cdot \alpha\)（其中 \(\delta < \beta\)）中最小的大于或等于它们的序数。按\textbf{后继序数}和\textbf{极限序数}的情况分别写为：
\begin{itemize}
\item \(\alpha^0=1~\)
\item 对于后继序数 \(S(\beta)\)，定义：\(\alpha^{S(\beta)} = (\alpha^\beta) \cdot \alpha~\)
\item 当 \(\beta\) 是极限序数时：\(\alpha^\beta = \bigcup_{0 < \delta < \beta} (\alpha^\delta)\)
\end{itemize}
如果指数 \(\beta\) 是一个有限数，这两个定义都会大大简化：\(\alpha^\beta\) 此时只是 \(\beta\) 个 \(\alpha\) 相乘的积。例如，\(\omega^3 = \omega \cdot \omega \cdot \omega\)，\(\omega^3\) 的元素可以看作是自然数的三元组，并按字典序排列，其中最低位优先。这与自然数的普通幂运算一致。

对于无限指数，幂的定义可能就不那么直观了。例如，\(\alpha^\omega\) 可以看作是\(\alpha\)中元素的有限序列组成的集合，并按照适当的顺序排序。等式 \(2^\omega = \omega\) 表示：由0和1组成的有限序列可以通过二进制数系统与自然数一一对应。序数 \(\omega^\omega\) 可以看作是“自然数的有限序列”这种排序类型；\(\omega^\omega\)中的每个元素（也就是每个小于\(\omega^\omega\)的序数）都可以唯一地表示为如下形式：\(\omega^{n_1}c_1+\omega^{n_2}c_2+\cdots+ \omega^{n_k}c_k\)其中 \(k\)、\(n_1\)、\(\dots\)、\(n_k\)是自然数，\(c_1\)、\(\dots\)、\(c_k\)是非零自然数，且 \(n_1 > n_2 > \cdots > n_k\)。

同样的结论在更一般的情况下也成立：\(\alpha^\beta\)中的每个元素（即每个小于\(\alpha^\beta\)的序数）都可以唯一地表示为如下形式：\(\alpha^{b_1}a_1 + \alpha^{b_2}a_2 + \cdots + \alpha^{b_k}a_k\)其中，\(k\)是一个自然数，\(b_1,\dots, b_k\)是小于\(\beta\)的序数，且满足 \(b_1 > \cdots > b_k\)，而\(a_1,\dots, a_k\)是小于\(\alpha\)的非零序数。这个表达式对应一个函数 \(f : \beta \to \alpha\)，其作用是将\(b_i\)映射到\(a_i\)（对\(i = 1,\dots, k\)），并将\(\beta\)中的其他元素全部映射为0。

虽然序数幂和基数幂使用相同的指数表示法，但它们是完全不同的运算，不应混淆。基数幂 \( A^B \) 被定义为从 \( B\to A \) 的所有函数组成的集合的基数，而序数幂 \(\alpha^\beta\) 仅包含具有有限支撑（finite support）的函数 \(\beta \to \alpha\)，通常其基数要小得多。

为了避免将序数幂与基数幂混淆，可以在前者（序数幂）中使用表示序数的符号（例如 \(\omega\)），而在后者（基数幂）中使用表示基数的符号（例如 \(\aleph_0\)）。
\subsubsection{属性}
\begin{itemize}
\item \(\alpha^0 = 1\)。
\item 如果 \(0 < \alpha\)，那么 \(0^\alpha = 0\)。
\item \(1^\alpha = 1\)。
\item \(\alpha^1 = \alpha\)。
\item \(\alpha^\beta \cdot \alpha^\gamma = \alpha^{\beta + \gamma}\)。
\item \((\alpha^\beta)^\gamma = \alpha^{\beta \cdot \gamma}\)。
\item 存在 \(\alpha\)、\(\beta\) 和 \(\gamma\) 使得 \((\alpha \cdot \beta)^\gamma \neq \alpha^\gamma \cdot \beta^\gamma\)。例如：\((\omega \cdot 2)^2 = \omega \cdot 2 \cdot \omega \cdot 2 = \omega^2 \cdot 2 \neq \omega^2 \cdot 4\)
\item 序数幂运算在右侧参数上是严格递增且连续的：如果 \(\gamma > 1\) 且 \(\alpha < \beta\)，那么\(\gamma^\alpha < \gamma^\beta\)
\item 如果 \(\alpha < \beta\)，则\(\alpha^\gamma \leq \beta^\gamma\)例如，\(2 < 3\)，但
\(2^\omega = 3^\omega = \omega\)
\item 如果 \(\alpha > 1\) 且 \(\alpha^\beta = \alpha^\gamma\)，则 \(\beta = \gamma\)。但如果 \(\alpha = 1\) 或 \(\alpha = 0\)，这个性质就不成立。
\item 对任意 \(\alpha\) 和 \(\beta\)，如果 \(\beta > 1\) 且 \(\alpha > 0\)，则存在唯一的 \(\gamma\)、\(\delta\) 和 \(\rho\) 使得\(\alpha = \beta^\gamma \cdot \delta + \rho\)其中\(0 < \delta < \beta\)且\(\rho < \beta^\gamma\)
\end{itemize}
Jacobsthal 证明：方程 \(\alpha^\beta = \beta^\alpha\)的唯一解（在 \(\alpha\leq\beta\) 的条件下是：\(\alpha = \beta\)，或\(\alpha = 2\) 且\(\beta = 4\)或\(\alpha\)是任意极限序数，且\(\beta=\varepsilon_\alpha\)，其中\(\varepsilon\)是大于\(\alpha\)的某个\(\varepsilon\)-数。
\subsection{超越指数运算}  
在序数运算中，除了加法、乘法和指数运算之外，还有一些更高级的运算，例如序数版本的四次方运算（tetration）、五次方运算（pentation）和六次方运算（hexation）。另请参见 Veblen 函数。
\subsection{康托范式} 
每个序数 \(\alpha\) 都可以唯一地表示为以下形式：\(\omega^{\beta_1} c_1 + \omega^{\beta_2} c_2 + \cdots + \omega^{\beta_k} c_k\)其中：\(k\)是一个自然数，\(c_1, c_2, \dots, c_k\) 是非零自然数，\(\beta_1 > \beta_2 > \dots > \beta_k \geq 0\) 是序数。当 \(\alpha = 0\) 时，这是一个退化情况，此时 \(k = 0\)，并且没有 \(\beta_i\) 或 \(c_i\)。这种 \(\alpha\) 的分解称为康托范式（Cantor normal form, CNF），可以看作是一种**以 \(\omega\) 为底的进位制表示法。\(\omega\) 的最高指数 \(\beta_1\) 被称为**\(\alpha\) 的阶，满足：\(\beta_1 \leq \alpha\)仅当 \(\alpha = \omega^\alpha\) 时，才有 \(\beta_1 = \alpha\)。在这种情况下，康托范式无法将该序数表示为更小序数的组合，关于这种情况的详细说明见下文。

康托范式的一种小变体通常更容易使用，即将所有系数 \(c_i\) 设为 1，并允许指数相等。换句话说，每个序数 \(\alpha\) 都可以唯一地表示为：\(\omega^{\beta_1} + \omega^{\beta_2} + \cdots + \omega^{\beta_k}\)其中：\(k\) 是一个自然数，\(\beta_1 \geq \beta_2 \geq \dots \geq \beta_k \geq 0\) 是序数。

康托范式的另一种变体是“以 \(\delta\) 为底的展开式”（base-\(\delta\) expansion），其中 \(\omega\) 被替换为任意 \(\delta > 1\) 的序数，并且 \(c_i\) 是小于 \(\delta\) 的非零序数。

康托范式使我们能够唯一地表示——并排序——那些通过有限次加法、乘法和以 \(\omega\) 为底的指数运算，从自然数构造出来的序数 \(\alpha\)。换句话说，如果我们假设在康托范式中 \(\beta_1 < \alpha\)，那么我们也可以将这些指数 \(\beta_i\) 进一步用康托范式表示，并对每个 \(\beta_i\) 递归地做同样的假设和处理。这样，我们就得到了一个用于表示这些序数的完整符号系统。例如：
\[
\omega^{\omega^{\omega^7 \cdot 6 + \omega + 42} \cdot 1729 + \omega^9 + 88} \cdot 3 + \omega^{\omega^{\omega}} \cdot 5 + 65537~
\]
这个表达式表示一个序数。

序数 \(\varepsilon_0\)（读作“epsilon nought”或“epsilon zero”）是由**有限长度的康托范式算术表达式**构成的序数集合，这些表达式必须是**遗传地非平凡的**。这里的“非平凡”是指：当 \(0 < \alpha\) 时，康托范式中的最高指数 \(\beta_1 < \alpha\)。\(\varepsilon_0\) 是**无法用有限个\(\omega\)的算术表达式表示的最小序数**，也是满足以下条件的最小序数：\(\varepsilon_0 = \omega^{\varepsilon_0}\)也就是说，在康托范式中，\(\varepsilon_0\)的指数不比\(\varepsilon_0\)本身小。

它是以下序列的极限：
\[
0, 1 = \omega^0, \omega = \omega^1, \omega^\omega, \omega^{\omega^\omega}, \dots~
\]
序数 \(\varepsilon_0\) 在算术中具有重要意义，主要原因之一是它衡量了一阶皮亚诺算术的证明论强度。具体来说，皮亚诺公理可以证明对所有小于 \(\varepsilon_0\) 的序数成立的超限归纳，但无法证明扩展到 \(\varepsilon_0\) 本身的超限归纳。

康托范式还可以帮助我们计算序数的和与积：例如，要计算和时，我们只需要知道（参见“加法”和“乘法”部分列出的性质）：  
\[
\omega^\beta c + \omega^{\beta'} c' = \omega^{\beta'} c'~
\]

如果\(\beta' > \beta\)，则：\(\omega^\beta c + \omega^{\beta'} c' = \omega^{\beta'} c'\)（较高指数项主导整个和）。如果\(\beta' = \beta\)，可以应用分配律，将它改写为：\(\omega^\beta (c + c')\)如果\(\beta' < \beta\)，这个表达式已经是康托范式，不需要进一步简化。对于乘法运算，关键性质是：当\(\alpha\)是康托范式的序数，且：\(0 < \alpha = \omega^{\beta_1}c_1 + \cdots + \omega^{\beta_k}c_k\)且\(\beta' > 0\)，那么：
\[
\alpha\omega^{\beta'} = \omega^{\beta_1 + \beta'}~
\]
如果\(n\)是非零自然数，则：
\[
\alpha n = \omega^{\beta_1}(c_1 \cdot n) + \omega^{\beta_2}c_2 + \cdots + \omega^{\beta_k}c_k~
\]
要比较用康托范式表示的两个序数，首先比较它们的第一个指数\(\beta_1\)，然后比较第一个系数\(c_1\)，接着比较第二个指数\(\beta_2\)，再比较第二个系数\(c_2\)，依此类推。在第一个出现不相等的地方，拥有较大分量的那个序数就是较大的序数。如果两个序数在所有对应的分量都相等，但其中一个比另一个先结束，那么先结束的序数较小。
\subsection{分解为素数} 
恩斯特·雅可布斯塔尔证明，序数满足一种唯一分解定理的形式：每个非零序数都可以表示为有限个素序数的乘积。这种素序数分解通常不是唯一的，但存在一个“最小分解”，该分解在重新排列有限素因子的顺序后是唯一的（Sierpiński，1958）。

素序数是指大于1、且不能表示为两个更小序数乘积的序数。一些最早的素序数包括：  
\(2\), \(3\), \(5\), …, \(\omega\), \(\omega + 1\), \(\omega^2 + 1\), \(\omega^3 + 1\), …, \(\omega^\omega\), \(\omega^\omega + 1\), \(\omega^\omega + 1 + 1\), … 素序数可以分为三类：
\begin{itemize}
\item 有限素数：\(2\), \(3\), \(5\), …  
\item 形如 \(\omega^{\omega^\alpha}\) 的序数，其中\(\alpha\)是任意序数。这类是极限素序数，也叫做\(\delta\)数，它们是对乘法封闭的超限序数。  
\item 形如 \(\omega^\alpha + 1\) 的序数，其中\(\alpha > 0\)。这类是无限的后继素数，它们是\(\gamma\)数（加法不可分解序数）的后继序数。
\end{itemize}
素因子分解并非唯一：例如，\(2 \times 3 = 3 \times 2\)，\(2 \times \omega = \omega\)，\((\omega + 1) \times \omega = \omega \times \omega\)，和\(\omega \times \omega^\omega = \omega^\omega\)。然而，存在唯一的素因子分解，但需满足以下额外条件：  
\begin{itemize}
\item 所有极限素数必须出现在任何后继素数之前。  
\item 如果素因子分解中的两个相邻素数都是极限素数或都是有限素数，则后者必须小于或等于前者。
\end{itemize}
这个素因子分解可以通过康托范式轻松读出，步骤如下：
\begin{itemize}
\item 首先，将序数写成乘积形式 \(\alpha \beta\)，其中\(\alpha\)是康托范式中最小的\(\omega\)的幂，而\(\beta\)是一个后继序数。
\item 如果\(\alpha = \omega^\gamma\)，那么把\(\gamma\)用康托范式表示，就可以把\(\alpha\)展开成极限素数的乘积。
\item 接着查看\(\beta\)的康托范式。如果\(\beta = \omega^\lambda m + \omega^\mu n +\)（更小的项），那么：\(\beta = (\omega^\mu n + \text{更小的项}) \cdot (\omega^{\lambda - \mu} + 1)m\)这将\(\beta\)分解为一个较小序数、一个素数和一个自然数 \(m\) 的乘积。不断重复这个过程，并把出现的自然数进一步分解为素数，最后就得到了\(\beta\)的素因子分解。
\end{itemize}
因此，康托范式表示的序数  
\[
\omega^{\alpha_1}n_1 + \cdots + \omega^{\alpha_k}n_k~
\]
（其中 \(\alpha_1 > \cdots > \alpha_k\)）  

其**最小的素因子分解**（由无限素数和自然数组成）是：  

\[
\left(\omega^{\omega^{\beta_1}} \cdots \omega^{\omega^{\beta_m}}\right)n_k(\omega^{\alpha_{k-1} - \alpha_k} + 1)n_{k-1}(\omega^{\alpha_1 - \alpha_2} + 1)n_1~
\]

其中，每个 \(n_i\) 都要替换为其按非递增顺序排列的有限素数分解。

此外：
\[
\alpha_k = \omega^{\beta_1} + \cdots + \omega^{\beta_m}~
\]
并且：
\[
\beta_1 \geq \cdots \geq \beta_m~
\]
\subsection{大型可数序数} 
如上所述，小于\(\varepsilon_0\)的序数的康托范式可以用一个仅包含加法、乘法和幂运算的符号表示，还需要每个自然数的常量符号以及\(\omega\)这个常量符号。  

我们可以进一步简化，去掉无限多个自然数符号，只使用常量符号\(0\)和一个后继运算符\(S\)（例如，自然数4可以表示为\(S(S(S(S(0))))\)）。  

这种表示系统就是一种序数表示法：用有限字母表来表示序数。这种特定的表示法叫做算术序数表达式的集合（arithmetical ordinal expressions），它可以表示所有小于\(\varepsilon_0\)的序数，但不能表示\(\varepsilon_0\)本身。  

除了这种表示法之外，还有其他的序数表示法，它们可以表示远远大于\(\varepsilon_0\)的序数。但由于任何给定的序数表示法只能使用有限字母表上的可数长度字符串，所以对于每个具体的序数表示法，总会存在某个小于\(\omega_1\)（第一个不可数序数）的序数无法表示。这样的序数被称为大型可数序数（large countable ordinals）。

加法、乘法和幂运算都是原始递归序数函数的例子，而更一般的原始递归序数函数可以用来描述更大的序数。
\subsection{自然运算} 
序数的自然和（natural sum）和自然积（natural product）由Gerhard Hessenberg于1906年定义，有时也被称为Hessenberg和或Hessenberg积（Sierpiński 1958）。自然和通常记作\(\alpha \oplus \beta\)或\(\alpha \# \beta\)自然积通常记作\(\alpha \otimes \beta\)或\(\alpha \divideontimes \beta\)  

设\(\alpha = \omega^{\alpha_1} + \cdots + \omega^{\alpha_k}\)和\(\beta = \omega^{\beta_1} + \cdots + \omega^{\beta_\ell}\)是\(\alpha\)和\(\beta\)的康托范式表示（即：\(\alpha_1 \geq \cdots \geq \alpha_k\)和\(\beta_1 \geq \cdots \geq \beta_\ell\)）。将所有的指数\(\alpha_1, \ldots, \alpha_k, \beta_1, \ldots, \beta_\ell\)按非递增顺序排序，记为\(\gamma_1, \gamma_2, \ldots, \gamma_{k+\ell}\)那么，自然和\(\alpha \oplus \beta\)定义为：
\[
\alpha \oplus \beta = \omega^{\gamma_1} + \cdots + \omega^{\gamma_{k+\ell}}~
\]

\(\alpha\) 和 \(\beta\) 的自然积定义为：
\[
\alpha \otimes \beta = \bigoplus_{1 \leq i \leq k \atop 1 \leq j \leq \ell} \omega^{\alpha_i \oplus \beta_j}~
\]

举例,设：\(\alpha = \omega^{\omega^{\omega}} + \omega\)和\(\beta = \omega^{\omega} + \omega^5\)那么：\(\alpha \oplus \beta = \omega^{\omega^{\omega}} + \omega^{\omega} + \omega^5 + \omega\)（自然和把所有项按照降序排列并保留全部项）而普通加法：\(\alpha + \beta = \omega^{\omega^{\omega}} + \omega^{\omega} + \omega^5\)（普通加法在相同指数项上可能会合并或省略较小项）对于自然积：\(\alpha \otimes \beta = \omega^{\omega^{\omega} + \omega} + \omega^{\omega^{\omega} + 5} + \omega^{\omega + 1} + \omega^6\)而普通乘法：\(\alpha\beta = \omega^{\omega^{\omega} + \omega} + \omega^{\omega^{\omega} + 5}\)

自然和和自然积都是交换的和结合的。自然积对自然和是分配的，即：\(\alpha\otimes (\beta \oplus \gamma) = (\alpha \otimes \beta)\oplus(\alpha\otimes \gamma)\)这些运算还具有单调性，具体来说：如果\(\alpha < \beta\)，那么：\(\alpha \oplus \gamma<\beta \oplus \gamma\)如果\(\alpha \leq\beta\)，那么：\(\alpha \otimes \gamma \leq \beta\otimes\gamma\)如果\(\alpha < \beta\)且\(\gamma > 0\)，那么：\(\alpha\otimes\gamma<\beta \otimes \gamma\)

此外：
\[
\underbrace{\alpha \oplus \cdots \oplus \alpha}_{n} = \alpha \otimes n~
\]
我们始终有：\(\alpha + \beta \leq \alpha \oplus \beta\)以及\(\alpha \beta \leq \alpha \otimes \beta\)如果\(\alpha<\omega^\gamma\) 且\(\beta<\omega^\gamma\)，那么：\(\alpha\oplus\beta<\omega^\gamma\)如果\(\alpha < \omega^{\omega^\gamma}\)且\(\beta<\omega{\omega^\gamma}\)，那么：\(\alpha \otimes \beta < \omega^{\omega^\gamma}\)

自然和和自然积在右侧参数上并非连续的，例如：\[\lim_{n < \omega} \alpha \oplus n = \alpha + \omega~\]而不是：\(\alpha \oplus \omega\)同样：\[\lim_{n < \omega}\alpha \otimes n = \alpha\omega~\]而不是：
\(\alpha \otimes \omega\)

自然和与自然积实际上和John Conway的超现数量域（surreal numbers）中定义的加法和乘法（限制在序数上的情况）是相同的。

自然运算出现在良部分序理论（well partial orders, WPO）中。给定两个良部分序\(S\)和\(T\)，它们的类型（最大线性化序类型）分别为\(o(S)\)和\(o(T)\)。它们的不交并集的序类型是：\(o(S)\oplus o(T)\)它们的直积的序类型是：\(o(S)\otimes o(T)\)这里的自然和和自然积，正是用这种方式定义的。具体来说，如果\(S\)和\(T\)分别是两个序数 \(\alpha\)和\(\beta\)，那么：\(\alpha \oplus\beta\)是最大线性序类型，它扩展了\(\alpha\)和\(\beta\)的不交并（作为部分序）。\(\alpha \otimes\beta\)是最大线性序类型，它扩展了\(\alpha\)和\(\beta\)的直积（作为部分序）。这种定义的一个重要应用是：如果\(\alpha\)和\(\beta\)都是某个更大的全序集的子集，那么它们的并集的序类型最多是：\(\alpha \oplus \beta\)如果\(\alpha\)和\(\beta\)都是某个有序阿贝尔群的子集，那么它们的\textbf{和}的序类型最多是：\(\alpha \otimes \beta\)

我们也可以通过同时超限递归（simultaneous transfinite recursion）来定义自然和 \(\alpha \oplus \beta\)：  
\[
\alpha \oplus \beta~
\]
是严格大于以下所有序数的最小序数：\(\alpha \oplus \gamma\)，对所有 \(\gamma < \beta\);\(\gamma \oplus \beta\)，对所有 \(\gamma < \alpha\)

类似地，我们可以通过同时超限递归来定义自然积 \(\alpha \otimes \beta\)：  
\[
\alpha \otimes \beta~
\]
是满足以下条件的最小序数\(\gamma\)：对所有\(\varepsilon < \alpha\)和\(\delta < \beta\)，有：\((\alpha \otimes \delta) \oplus (\varepsilon \otimes \beta) < \gamma \oplus (\varepsilon \otimes \delta)\)

此外，也可以参考超现数（surreal numbers）相关条目中的自然乘法定义；不过，超现数中的定义依赖于超现数减法，而减法在序数中并未定义。