% 从图灵机到 C 语言
% license Usr
% type Tutor

\pentry{逻辑门、布尔运算\nref{nod_LogicG}}{nod_cab0}

\textbf{图灵机要素}：无限长纸带、有限字符集（通常是 ${0,1,\square}$， 方块代表空）、有限的状态集、根据状态和当前字符决定下一步行为（写入、移动）、初始状态、停机状态。

图灵可以完成任何计算机可以完成的事情。如果一个编程语言可以做图灵机的任何事情（除了纸带不是无限长），那么他就是图灵完备的。

推荐一个 Steam 上的游戏\href{https://store.steampowered.com/app/1444480/Turing_Complete/}{图灵完备（Turing Complete）}，自己从逻辑门搭建汇编语言。

\subsubsection{真实计算机}
\textbf{纸带被划分为几个部分}：\textbf{代码段}（储存程序指令，一般只读）、\textbf{数据段}（分为只读和读写两部分，只读部分是 literal，读写部分是全局变量和 static 变量）、\textbf{栈}（函数局部变量）、\textbf{堆}（动态分配内存）。

\begin{itemize}
\item 汇编语言的\textbf{变量}没有类型，就对应一个地址和长度。
\item 没有算符更没有重载，只有\textbf{函数}，每个函数对应代码段的一个地址。
\item 每个\textbf{函数从栈的最顶端读取固定长度的函数参数，结束时清空参数，输出到栈的顶端（实际上输出到寄存器）}。
\item 这其实就是更具体的图灵机，纸带划分为指令部分和内存部分。每个周期，图灵机先从\textbf{程序计数器（program counter）}（程序计数器可以看作图灵机状态的一部分）读取下一个要执行的 CPU 指令（可以简单理解为与或非，或 NAND，作用对象为固定的寄存器，当然也需要一些指令把数据在寄存器和内存地址之间复制）、该指令要操作的数据在内存中的固定地址，然后计算。
\item 更具体的图灵机：可以认为图灵机本身包含了 cpu 的硬件运算能力，实现与、或、非、整数和浮点数加法等（其实最基本的只要掌握，其他硬件能力都可以用代码段来软实现），也包含了这些运算所需的寄存器。程序计数器。
\item \textbf{纸带被划分为几个部分}：\textbf{代码段}（储存程序指令，一般只读）、\textbf{数据段}（分为只读和读写，只读部分是 literal，读写部分是全局变量和 static 变量）、\textbf{栈}（函数局部变量）、\textbf{堆}（动态分配内存）。
\item C 语言的静态类型只是用于辅助编译器帮用户检查是否用对了函数，编译完成后静态类型丢失，所有的函数的参数都只是给定位置的一串 0 和 1。
\item 理论上用户完全可以所有函数变量都使用 \verb`const void *`。 甚至连每个变量的字节数都不需要用别的变量储存，因为每个函数是知道每个变量的长度的。
\item 人类很喜欢\textbf{重载（overload）}，机器不喜欢（例如 + 号有很多含义，自然语言更是）。 即使是 C 语言也有算符 overload 例如 \verb`+`。 该算符其实不是一个函数地址（或者 cpu 指令），而是根据变量类型在编译时决定具体用哪一个。 C++ 把 overload 推向了全新的境界（尤其是模版）。
\item \textbf{多态（polymorphism）}主要指的是根据运行时的类型信息调用不同函数而不是编译时的函数重载， 二者有本质区别。 前者根据运行时变量的值决定调用哪个地址的函数，而普通函数重载是编译时写死到代码段，运行时无法改变。
\end{itemize}
