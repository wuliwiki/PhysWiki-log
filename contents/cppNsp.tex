% C++ 的 namespace

\begin{issues}
\issueDraft
\end{issues}

\begin{itemize}
\item 使用 `namespace` 函数的一个重要（坑爹）例外就是， `argument` 的 `namespace` 会从 `function` 取消． 这样 namespace 中的函数就有可能和 namespace 外的函数发生冲突！解决的办法就是定义自己的 namespace，或者直接更改函数名．
\item STL 中 include 的 c header 并没有任何 namespace， 例如 `#include <iostream>` 以后， `getchar()` 没有 namespace． 这是历史遗留问题．
\item 定义 namespace 的大括号内部如果 using 其他 namespace 中的 name，那么这个 name 也会在这个 namespace 中出现．所以尽量不要！
\item 定义 namespace 的大括号中如果定义了一个 name，那么大括号外定义的相同的名字就会被隐藏， 即使是不同的函数 overloading 也会被隐藏． 可以在函数名前面加 global namespace `::`．
\item 如果有一个没有 namespace 的函数和一个有 namespace 的同 signature 函数， 使用 using declaration 不会发生冲突（没有 namespace 的函数被隐藏），但 using directive 就会冲突！
\item 在 global namespace 中不要使用开头有下划线的名字．
\item 如果在 `namespace A {}` 内部使用 `using namespace B;` 在 `namespace A {}` 外部使用 `using A::xx;` 是安全的， 即不会引入 `using namespace B`．但如果使用 `using namespace A`， 则会引入 `using namespace B`．
\item 即使在 `namespace A {}` 内部使用 `using namespace B;`  新定义的函数也不会与 B 中的同名函数 overload， 而是会直接覆盖 B 中的函数．
\end{itemize}
