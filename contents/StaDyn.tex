% 静态和动态语言笔记（计算机）
% license Usr
% type Note

\begin{issues}
\issueDraft
\end{issues}

\textbf{最原始的编程：1.变量没有类型，就对应一个地址， 2.没有算符更没有重载，每个函数对应一个函数地址， 3.不区分 stack 和 heap，每个函数从内存固定几个地址读取固定长度的函数参数，输出到固定地址固定长度。 这其实就是更具体的图灵机，纸带划分为指令部分和内存部分。每个周期，图灵机先从 program counter 读取下一个要执行的指令、该指令要操作的数据在内存中的固定地址，然后计算（其实归根结底图灵机只需要认识与，或，非三种指令中的两种）。}

\textbf{图灵机要素}：无限长纸带、有限字符集、有限的状态集、根据状态和当前字符决定下一步行为（写入、移动）、初始状态、停机状态。

更具体的图灵机：可以认为图灵机本身包含了 cpu 的硬件运算能力，实现与、或、非、整数和浮点数加法等（其实最基本的只要掌握与或非中两个，其他硬件能力都可以用代码段来软实现），也包含了这些运算所需的寄存器。程序计数器。

\textbf{纸带被划分为几个部分}：\textbf{代码段}（储存程序指令，一般只读）、\textbf{数据段}（分为只读和读写，只读部分是 literal，读写部分是全局变量和 static 变量）、\textbf{栈}（函数局部变量）、\textbf{堆}（动态分配内存）。

\textbf{静态类型只是用于辅助编译器，编译完成后静态类型丢失，所有的函数的参数都只是给定位置的一串 0 和 1， 而动态类型信息在编译时是不可知的。 这就是为什么静态类型和动态类型混用会那么痛苦！}

\textbf{静态类型的唯一作用就是告诉编译器应该选择什么函数地址！否则用户完全可以所有变量都使用 \verb`const void *`。 甚至连每个变量的字节数都不需要用别的变量储存，因为每个函数是知道每个变量的长度的。}

\textbf{人类很喜欢 overload，机器不喜欢。 即使是 C 语言也有 overload 例如 \verb`+` 算符其实不是一个函数地址（或者 cpu 指令），而是根据变量类型决定具体用哪一个，只是不能用户定义罢了。 C++ 把 overload 推向了全新的境界。}

\textbf{多态（polymorphism）}主要指的是运行时的类型多态。 运行时多态和普通函数重载有本质区别。 前者根据运行时变量的值决定调用哪个地址的函数，而普通函数重载是编译时写死到代码段，运行时无法改变。另外，运行时也会有方法多态。

\textbf{其实编程最核心的两个概念，一个是\textbf{方法}，一个是\textbf{类型}。 如果是一切都是静态的，那么可以把每个方法结合每种适用类型都写一个具体的 c 函数， 什么时候需要就调用相应的就好，可以是用户直接选择调用哪个函数指针也可以是编译时编译器根据重载或者模板自动决定，给编程者一种运行时多态的错觉。 严格来说，运行时用户输入的任何不同东西都只是数据，既没有不同类型也没有不同方法（例如 scanf 获取的归根结底都只是字符串罢了）。但程序员还是想给运行时数据赋予类型和方法的概念，且想让它们与编译时的类型和方法相对应。 例如一个计算机程序中用户运行时输入 \verb`1.3 + 2.2`， 这里的运行时类型和方法都是运行时才知道的。 另外，在一些其他程序中我们只需要运行时方法或类型中的一个就足够了。 最直接的解决方法仍然是，运行时类型都用 \verb`void *` 和一个类型 id 表示， 方法也有一个 id， 程序获取输入后， 给 \verb`1.3`， \verb`2.2` 赋予动态类型， 查表得到 \verb`+` 运算适用于该类型的的函数指针并调用（你可以想象成先储存了一个函数指针的矩阵，不同行是不同方法，不同列是不同类型）。 如何把这个过程抽象呢？面对过程编程和面对对象编程给出了不同的答案！面对过程编程就是把函数指针表中的每种方法也就是每行写成一个抽象的函数叫做 \verb`any plus(any a, any b)`（其实 \verb`any` 简单来说就是一个 \verb`void *` 和一个 \verb`typeid`）， 然后在这个函数内部判断调用这行指针中的哪一个。面对对象编程的解决动态类型的方法是虚函数，把所有可能出现的动态对象都从一个有虚函数的父类继承。 这样程序看到表达式后， 先根据类型 \verb`new` 两个浮点数对象， 然后看到 \verb`+` 再调用 \verb`1.3` 这个对象的 \verb`plus()` 方法。 所以面对象编程是把函数指针表中的每一列写成一个类型的不同方法，运行时用父类代替 \verb`any`， 再决定动态方法需要调用的成员函数。实现上，每个父类的 object 都有一个\textbf{虚函数表指针（vptr）}， 每一个子类都有一个\textbf{虚函数表（vtable）}， 所以父类对象并不直接像 any 一样存 typeid， 而是用虚函数表指针来区分所表示的不同子类。 编译好的程序在运行时会根据父类对象的虚函数表指针来判断使用哪个子类的虚函数表，再根据 \verb`+` 判断是虚函数表中的第几个函数，调用 \verb`a.plus(b)`。}对一般人来说肯定还是面向过程比较方便虚函数什么的不花点时间是学不懂的。

\textbf{不必要的动态类型}：很多时候其实并不会真正出现真正的动态类型和动态方法， 但我们为了把库写的更抽象，仍然可能会使用动态类型如 \verb`any plus(any a, any b)` 或者虚函数子类，这降低了编程的难度，让静态语言有了动态语言的味道，但浪费了不必要的性能开销。因为每次运行都需要动态检查类型信息。 性能最高的做法只有函数重载和模板编程，觉得模板编程难？用代码生成容易得多，也就是对编程进行编程（“我不写程序，我只写写程序的程序”）。

\textbf{举例：要写一个函数（可以是一个函数也可以是重载或模板）更新数据库中的一整个表（\autoref{sub_SQLite_1}~\upref{SQLite}）。不同情况调用时可能会需要不同的表尺寸（但仍然不是真的动态，调用时尺寸是决定好的），每列有不同的类型。最高性能最理想的办法自然是写 c++ 模板了，每一列的数据可以用一个 tuple 表示， 但你光弄清怎么获取 tuple 的个数， 怎么给 tuple 做一个循环都要费老鼻子劲了！然后有开始抱怨为什么 C++ 那么难用！这就是既要性能也要抽象的代价，也是为什么 C++ 如此复杂的原因。而且就算你用，调用程序的时候用来装数据的容器也未必是 tuple，不是的话还得整个表复制一次。} 好，你最后终于放弃模板去用 \verb`any` 了， 但是数据库提供的 api 哪会支持什么 \verb`any`？ 你每次要 bind 还需要写一大堆判断检查 \verb`any` 的动态类型再调用合适的 \verb`bind` 函数。 这么多判断当然只想要写一次！所以还得把 \verb`bind` 这个方法抽象一下写个 \verb`bind(statement, any, col)` 函数！ 如果用 oop 怎么弄呢？ 那肯定是数据库需要 bind 的所有类型都从一个虚父类继承，每个子类都写一个 bind 成员函数。

C 语言的每一个函数（如果没有被 inline）都对应二进制文件中的一个地址。 二进制文件是写好的，不能运行时修改的。内存中专门有一块区间用于存放程序指令。 CPU 有一个 program counter 就是用于记录当前执行到程序的哪个位置。程序指令在运行时是不可以改动的，写死在程序中的数据（literal）也不可以改动。

函数中的每个本地变量都对应 stack 上的一块固定大小的，相对位置也确定的内存。这些也是编译时候定死的。

运行时可以改变的东西一个是 stack 上的具体数据， 另一个就是 heap 中的动态内存分配以及上面的数据。

静态语言的类型信息在编译后就完全丢失了，除非手动以变量的形式保存。

静态语言和动态语言的最本质区别就是，静态语言的函数和变量都是对应到程序文件中和 stack 中的具体位置的。动态语言一切都是可以改变的，变量并不具有固定地址而是类似于指针，可以指向任何地方。 函数也不对应可执行文件的具体位置而是动态内存中的一些更一般的所谓 “指令” 而不是固定不可更改的机器码（例如 python 的字节码）。 运行时再 “理解” 这些指令，必要的时候调用其他字节码函数，或者把 program counter 转入动态库文件的机器码。 这有点类似于虚拟机。 这就容易理解为什么动态语言比较慢了，因为字节码不可能直接由 cpu 执行，例如一个加法函数把两个变量相加，每次都走到这要现场根据变量的动态类型判断应该调用机器码中哪个版本的加法。就是这些判断，以及多余的 program counter 的跳转导致程序变慢。

那么静态语言如何实现动态语言的灵活性呢？ 属于是 polymorphism。

判断语句和函数调用都可以根据运行时的数据让 program counter 跳到想要的地方。

所以即使有了 \verb`std::any` 也用起来并不顺手，因为我们老想把它和传统类型混用！例如我们希望它具有成员函数 \verb`any::get()` 可以直接输出它所代表的类型的变量。 这样我们就可以写出例如 \verb`a.get() + b.get()` 这样的代码。 但对于内建的 \verb`+` 运算是不可能做到的。

C++ 的 template 也好， function overload 也好， 本质上都是在编译时能让不同的类型自动选择不同的函数，但是函数一旦选择，在运行时就不可能修改了。 非 virtual 的成员函数也是根据 object 在编译时候的类型选择调用的函数地址。 而改函数的返回值的长度首先不能改变。你或许觉得 \verb`get` 可以根据 \verb`any` 的动态类型来判断返回值里面装什么数据， 且把类型也一块返回。 那其实就相当于返回一个 \verb`any` 呀！ 如果返回的类型只能在运行时决定，那么编译时编译器如何决定 \verb`+` 运算应该调用哪个地址的函数呢？ 那我们只好写一个 \verb`operator+()` 函数接收两个 any 并返回一个 any！ 所以如果你想达到动态语言那样的易用效果，就需要把所有函数都变为只接收 any 和只返回 any！ 那就相当于你创建了一个动态类型语言。
